En  un  examen  final  hay  N  alumnos  y  P  profesores.  Cada  alumno  resuelve  su  examen,  lo 
entrega  y  espera  a  que  alguno  de  los  profesores  lo  corrija  y  le  indique  la  nota.  Los 
profesores corrigen los exámenes respetando el orden en que los alumnos van entregando.  
a. Considerando que P=1. 
b. Considerando que P>1. 
c. Ídem  b.  pero  considerando  que  los  alumnos  no  comienzan  a  realizar  su  examen  hasta 
que todos hayan llegado al aula. 
Nota: maximizar la concurrencia y no generar demora innecesaria.

a.

Process Profesor{
    Examen examen;
    int resultado ,idAux;

    for(int i=0; i<N; i++){
        Admin!pedido();
        Admin?enviar(idAux,examen);
        resultado = CorregirExamen(examen);
        Alumno[idAux]!nota(resultado);
    }

}

Process Alumno[id:1..N]{
    Examen examen; //Se dispone
    int nota;

    //Se hace el examen
    Admin!Entregar(id,examen);
    Profesor?nota(nota);
}

Process Admin{
    cola Examenes;
    Examen examen;
    int idAux;

    do Alumno[*]?Entregar(idAux,examen){Examenes.push(idAux,examen)}
    □ not !Examenes.empty; 
        Profesor?pedido() ->Examenes.pop(idAux,examen)
                            Profesor!enviar(idAux,examen);
    od
}

b.

Process Profesor[id:1..P]{
    Examen examen;
    int resultado ,idAux;

    for(int i=0; i<N; i++){
        Admin!pedido(id);
        Admin?enviar(idAux,examen);
        resultado = CorregirExamen(examen);
        Alumno[idAux]!nota(resultado);
    }

}

Process Alumno[id:1..N]{
    Examen examen; //Se dispone
    int nota;

    //Se hace el examen
    Admin!Entregar(id,examen);
    Profesor[*]?nota(nota);
}

Process Admin{
    cola Examenes;
    Examen examen;
    int idAux, idP;

    do Alumno[*]?Entregar(idAux,examen){Examenes.push(idAux,examen)}
    □ not !Examenes.empty; 
        Profesor[*]?pedido(idP) ->Examenes.pop(idAux,examen)
                            Profesor[idP]!enviar(idAux,examen);
    od
}

c.

Process Entrada{
    int cant;
    do Alumno[*]?llegada() -> cant++;
    □ cant == N; Profesor[*]?espera -> for(int i; i < P; i++){
                        Profesor[*]?espera
                        }  
                        for(int i; i < N){
                            Alumno[i]!comenzar();
                        }
    od 
}

Process Profesor[id:1..P]{
    Examen examen;
    int resultado ,idAux;

    Entrada!espera();

    for(int i=0; i<N; i++){
        Admin!pedido(id);
        Admin?enviar(idAux,examen);
        resultado = CorregirExamen(examen);
        Alumno[idAux]!nota(resultado);
    }

}

Process Alumno[id:1..N]{
    Examen examen; //Se dispone
    int nota;

    Entrada!llegada();
    Entrada?comenzar();

    //Se hace el examen
    Admin!Entregar(id,examen);
    Profesor[*]?nota(nota);
}

Process Admin{
    cola Examenes;
    Examen examen;
    int idAux, idP;

    do Alumno[*]?Entregar(idAux,examen){Examenes.push(idAux,examen)}
    □ not !Examenes.empty; 
        Profesor[*]?pedido(idP) ->Examenes.pop(idAux,examen)
                            Profesor[idP]!enviar(idAux,examen);
    od
}